问题描述 :

　　形如2P-1的素数称为麦森数，这时P一定也是个素数。但反过来不一定，即如果P是个素数，2P-1不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是P=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。
　　任务：输入P（1000<P<3100000），计算2P-1的位数及最后500位数字（用十进制高精度数表示）

输入说明 :

输入只包含一个整数P（100<P<3100000）

不必验证2P-1与P是否为素数。

输出说明 :

第一行：十进制高精度数2P-1的位数。
第2-11行：十进制高精度数2P-1的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0）


输入范例 :

1279
输出范例 :

386
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000104079321946643990819252403273640855
38615262247266704805319112350403608059673360298012
23944173232418484242161395428100779138356624832346
49081399066056773207629241295093892203457731833496
61583550472959420547689811211693677147548478866962
50138443826029173234888531116082853841658502825560
46662248318909188018470682222031405210266984354887
32958028878050869736186900714720710555703168729087

#include<bits/stdc++.h>
using namespace std;
int a[1001], b[501];
void fun(int x) {
	if (x == 0) return;
	else fun(x / 2);
	for (int i = 1; i <= 500; i++) {
		for (int j = 1; j <= 500; j++) {
			if (x % 2 == 0) a[i + j - 1] += b[i] * b[j];
			else a[i + j - 1] += 2 * b[i] * b[j]  ;
		}
	}
	for (int i = 1; i <= 500; i++) {
		a[i + 1] += a[i] / 10;
		b[i] = a[i] % 10;

	}
	for (int i = 1; i <= 1000; i++) {
		a[i] = 0;
	}
}
int main() {
	int p;
	cin >> p;
	b[1] = 1;
	fun(p);
	cout << floor(log(2) / log(10) * p + 1) << endl;
	for (int i = 500; i >= 2; i--) {
		cout << b[i];
		if (i % 50 == 1)
		cout << endl;
	}
	cout << b[1] - 1;
	return 0;
}