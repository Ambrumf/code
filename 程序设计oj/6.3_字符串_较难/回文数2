问题描述 :

有一天，明明正在做作业，发现了一组很有趣的数字，例如1、11、313等等。他发现这些数字都是左右对称的，即不论你把这些数字从左读到右还是从右读到左，读出来的数字都是一样的。于是明明就把这个发现告诉了他爸爸。明明的爸爸是一名数学家，对此类型数字早有研究。他对明明说：“这些是回文数，是一种特殊的数字，即这些数字的左右两边是对称的。例如：11左右两边对称，313左右也是对称的。” 明明觉得这很有趣，接着问他爸爸还有什么和这类回文数有关的有趣的东西。明明的爸爸就说：“你把这些回文数转换成二进制数，看看是不是也符合回文数的规则。”明明发现1的二进制数也是1，符合回文数的规则；11的二进制数是1011，不符合回文数的规则；33的回文数是100001，符合回文数的规则。明明就回答爸爸说：“1和33的二进制数符合回文数的规则，11的二进制数则不符合回文数的规则。” 明明爸爸很满意明明的回答，又给了明明很多十进制数，让他判断在这些数中哪些数既是十进制回文数又是二进制回文数。明明起先做起来很有意思，但是时间一长就失去了兴趣。他想请你帮个忙，帮他写一个程序，用来判断一个数，它的十进制数是回文数，且它的二进制数也是回文数。

明明的问题可以归结为：给你一个整数（十进制），判断该整数的十进制数和它的二进制数是否全为回文数。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅有一行，每行有一个整数N（0 <= N <= 1000），表示要判断回文数的那个数。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为“Yes”或“No”，如果该数的十进制数和二进制数都是回文数，则输出“Yes”（不含双引号），否则输出“No”（不含双引号）。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

1
10
33
输出范例 :

Yes
No
Yes

#include <bits/stdc++.h>
using namespace std;
string bio(string a)
{
    int sum=0;
    while(!a.empty())
    {
        sum*=10;
        sum+=a.front()-48;
        a.erase(a.begin());
    }
    int bio=0,k=1;
    string t="";
    while(sum)
    {
        bio+=sum%2*k;
        sum/=2;
        k*=10;
    }
    while(bio)
    {
        t.insert(t.begin(),bio%10+48);
        bio/=10;
    }
    return t;


}

int main()
{
    string s;
    string bs;
    while(cin>>s)
    {
        bs=bio(s);
        string rs=s;
        string rbs=bs;
        reverse(rs.begin(),rs.end());
        reverse(rbs.begin(),rbs.end());
        if(rs==s && rbs==bs)cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}