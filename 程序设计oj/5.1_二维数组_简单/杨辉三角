问题描述 :

还记得中学时候学过的杨辉三角吗？

基本的特征是：

前提：端点的数为1.

每个数等于它上方两数之和。

每行数字左右对称，由1开始逐渐变大。

第n行的数字有n项。

你可以参考以下的图形：


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
　                         1
                         1   1   
                       1   2   1   
                     1   3   3   1   
                   1   4   6   4   1   
                 1   5   10  10  5   1   
               1   6   15  20  15  6   1   
             1   7   21  35  35  21  7   1   
           1   8   28  56  70  56  28  8   1   
         1   9   36  84  126 126 84  36  9   1   
       1   10  45  120 210 252 210 120 45  10  1   
     1   11  55  165 330 462 462 330 165 55  11  1    
   1   12  66  220 495 792 924 792 495 220 66  12  1
...


输入说明 :

输入数据首先包含一个正整数T ( T < 10 )，表示有 T 组测试数据, 每组测试数据只包含一个正整数n（1 <= n <= 20），表示将要输出的杨辉三角的层数。

输出说明 :

对应于每一个输入，请输出相应层数的杨辉三角，输出的整数之间用一个空格隔开，每一个杨辉三角后面加一个空行。

输出时，每一行的开头的“1”前面不需要空格，结尾的“1”后面也没有空格。

输入范例 :

2
5
8
输出范例 :

1
1 1
1 2 1
1 3 3 1
1 4 6 4 1

1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1


#include <iostream>

using namespace std;

int main()
{
    int a[22][22],n,T;
    for(int i=1;i<22;i++)
      for(int j=1;j<i+1;j++)
    {
        if(j==1 || j==i)a[i][j]=1;
        else a[i][j]=a[i-1][j-1]+a[i-1][j];
    }
    cin>>T;
    for(int k=0;k<T;k++)
    {
    cin>>n;
    for(int i=1;i<n+1;i++)
    {
        for (int j=1;j<i+1;j++)
        {if (j==i)cout<<a[i][j];
        else cout<<a[i][j]<<' ';}
        cout<<endl;
    }
    cout<<endl;
    }
    return 0;
}
