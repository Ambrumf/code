问题描述 :

明明是一家摩托车厂的老板，他的厂为了迎合市场中不同消费者的需求，会生产不同型号的摩托车，这为明明的厂带来了不小的收益。有一次，一位大客户来到明明的厂洽谈生意，他需要采购一批型号各不相同的摩托车，然后他把需要的摩托车的型号告诉了明明，接着明明就需要在他所生产的摩托车中寻找到型号匹配的，如果有则卖给那个客户，如果没有则只能对客户说抱歉了。明明忙了一个上午，终于把那个客户需要的摩托车全部配齐了，然后成功的谈成了这笔生意。 事后，明明发现了一个问题，如果每个客户来，都需要这样忙一个上午，才能够知道自己生产的摩托车能否满足客户的需要，这样的工作效率实在太低了，更有可能损失很多客户，这样对工厂未来的发展也是很不利的。

于是明明找到了你，你是一名程序设计专家，明明希望你能够帮他写一个程序，程序中记录了他工厂生产的所有摩托车的数据，然后当有客户拿着摩托车的订单来洽谈生意时，只要在这个程序中输入摩托车的型号数据，程序就能够查询出工厂是否生产这类的摩托车，这样就能提高明明工厂的工作效率，有助于工厂进一步发展。

摩托车需要记录的数据有以下一些：

                   摩托车的型号，摩托车的颜色和摩托车马达的类型。

例如，客户需要的摩托车型号如下：

摩托车型号

a1

a2

明明拥有的摩托车类型如下：

摩托车型号 摩托车颜色 摩托车马达型号

a1                   yellow              r1

a3                     red                 r3

a4                    blue                 r4

从中可以看出，明明的工厂只有a1这个型号的摩托车。

明明的问题可以归结为：写一个程序，程序中输入客户需要的摩托车型号和明明工厂拥有的摩托车的型号。在记录明明工厂的摩托车时，还要记录摩托车的颜色和摩托车马达的类型。程序要判断明明工厂拥有的摩托车是否能满足客户的需要。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有多行，测试数据的第一行有两个整数n（0<n<21）、m（0<m<100），分别表示客户需要的摩托车的型号的数量和明明工厂拥有的摩托车的型号的数量。接下来的n行，表示客户所需要的摩托车型号，再接下来的m行，表示明明工厂拥有的摩托车型号，另外还包括摩托车的颜色和马达类型。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一行或多行数据，这些数据表示明明工厂可以满足客户需要的摩托车的型号、颜色和马达型号，这三个数据之间用一个空格隔开。如果有多行，则输出时按照摩托车型号升序排列输出。

如果明明工厂没有一种型号的摩托车可以满足客户的需要，则输出“Not found!”，不包括双引号。详细格式请参考输出样例。每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

3 5
a1
a2
a3
b1 blue r1
c1 red r2
d1 blue r3
a1 green r2
a2 yellow r1
1 1
a1
b1 blue r1
输出范例 :

a1 green r2
a2 yellow r1
Not found!

#include<bits/stdc++.h>
using namespace std;
struct bike
{
    string type;
    string color;
    string md;
};
bool cmp(bike a,bike b)
{
    return a.type<b.type;
}
int main()
{
    string s[20];
    string t,a,b;
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        vector<bike> v;
        int flag=0;
        for(int i=0;i<n;i++)cin>>s[i];
        cin.get();
        while(m--)
        {

            cin>>t>>a>>b;
            bike tmp={t,a,b};
            for(int i=0;i<n;i++)if(s[i]==t){v.push_back(tmp);break;}
        }
        sort(v.begin(),v.end(),cmp);
        if(v.empty())cout<<"Not found!"<<endl;
        else for(int i=0;i<v.size();i++){cout<<v[i].type<<' '<<v[i].color<<' '<<v[i].md<<endl;}
    }
    return 0;

    
}